-- NuoDB database schema version 0.0.C to 0.0.D
-- Mark some NuoDB functions DETERMINISTIC
SET DELIMITER @
ALTER FUNCTION GetWord (
 word_value STRING,
 culture_name STRING
) RETURNS INTEGER DETERMINISTIC AS
 IF (word_value IS NOT NULL)
  INSERT INTO Word (value, culture) (
   SELECT word_value, Culture.code
   FROM Culture
   LEFT JOIN Word AS does_exist ON does_exist.value = word_value
    AND does_exist.culture = Culture.code
   WHERE Culture.name = culture_name
    AND does_exist.id IS NULL
  );
 END_IF;
 
 RETURN (
  SELECT id
  FROM Word
  JOIN Culture ON Culture.name = culture_name
  WHERE Word.value = word_value
   AND Word.culture = Culture.code
 );
END_FUNCTION;
@
SET DELIMITER ;

-- Default to en-US
SET DELIMITER @
ALTER FUNCTION GetWord (
 word_value STRING
) RETURNS INTEGER DETERMINISTIC AS
 RETURN (
  SELECT GetWord(word_value, 'en-US') FROM DUAL
 );
END_FUNCTION;
@
SET DELIMITER ;

SET DELIMITER @
ALTER FUNCTION GetIdentifier (
 ident_value STRING
) RETURNS INTEGER DETERMINISTIC AS
 IF (ident_value IS NOT NULL)
  INSERT INTO Word (value, culture) (
   SELECT ident_value, NULL
   FROM Dual
   LEFT JOIN Word AS does_exist ON does_exist.value = ident_value
    AND does_exist.culture IS NULL
   WHERE does_exist.id IS NULL
  );
 END_IF;

 RETURN (
  SELECT id
  FROM Word
  WHERE Word.value = ident_value
   AND Word.culture IS NULL
 );
END_FUNCTION;
@
SET DELIMITER ;

SET DELIMITER @
ALTER FUNCTION GetSentence (
 sentence_value STRING,
 culture_name STRING
) RETURNS INTEGER DETERMINISTIC AS
 IF (sentence_value IS NOT NULL)
  INSERT INTO Sentence (value, culture, length) (
   SELECT sentence_value, Culture.code, CHARACTER_LENGTH(sentence_value)
   FROM Culture
   LEFT JOIN Sentence AS does_exist ON does_exist.value = sentence_value
    AND does_exist.culture = Culture.code
   WHERE Culture.name = culture_name
    AND does_exist.id IS NULL
  );
 END_IF;
 RETURN (
  SELECT id
  FROM Sentence
  JOIN Culture ON Culture.name = culture_name
  WHERE Sentence.value = sentence_value
   AND Sentence.culture = Culture.code
 );
END_FUNCTION;
@
SET DELIMITER ;

-- Default to en-US
SET DELIMITER @
ALTER FUNCTION GetSentence (
 sentence_value STRING
) RETURNS INTEGER DETERMINISTIC AS
 RETURN (
  SELECT GetSentence(sentence_value, 'en-US') FROM DUAL
 );
END_FUNCTION;
@
SET DELIMITER ;

SET DELIMITER @
ALTER FUNCTION GetIdentityPhrase (
 phrase_value STRING
) RETURNS INTEGER DETERMINISTIC AS
 IF (phrase_value IS NOT NULL)
  INSERT INTO Sentence (value, culture, length) (
   SELECT phrase_value, NULL, CHARACTER_LENGTH(phrase_value)
   FROM Dual
   LEFT JOIN Sentence AS does_exist ON does_exist.value = phrase_value
    AND does_exist.culture IS NULL
   WHERE does_exist.id IS NULL
  );
 END_IF;
 RETURN (
  SELECT id
  FROM Sentence
  WHERE Sentence.value = phrase_value
   AND Sentence.culture IS NULL
 );
END_FUNCTION;
@
SET DELIMITER ;

-- DAG https://www.codeproject.com/Articles/22824/A-Model-to-Represent-Directed-Acyclic-Graphs-DAG-o
-- Tables
CREATE TABLE Edge (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  hops INTEGER NOT NULL DEFAULT 0,
  entry INTEGER,
  direct INTEGER,
  exit INTEGER,
  start INTEGER,
  stop INTEGER,
  created TIMESTAMP NOT NULL DEFAULT NOW(),
  PRIMARY KEY (id)
);
ALTER TABLE Edge ADD CONSTRAINT edge_entry FOREIGN KEY (entry) REFERENCES Edge(id);
ALTER TABLE Edge ADD CONSTRAINT edge_direct FOREIGN KEY (direct) REFERENCES Edge(id);
ALTER TABLE Edge ADD CONSTRAINT edge_exit FOREIGN KEY (exit) REFERENCES Edge(id);
ALTER SEQUENCE EDGE$IDENTITY_SEQUENCE START WITH 10000;

CREATE TABLE IndividualVertex (
  individual BIGINT NOT NULL,
  vertex INTEGER NOT NULL,
  type INTEGER,
  stop TIMESTAMP,
  created TIMESTAMP NOT NULL DEFAULT NOW()
);
CREATE INDEX individualvertex_individual ON IndividualVertex (individual);
CREATE UNIQUE INDEX individualvertex_individual_vertex ON IndividualVertex (individual, vertex);

CREATE TABLE VertexName (
  vertex INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  name INTEGER,
  created TIMESTAMP NOT NULL DEFAULT NOW(),
  PRIMARY KEY (vertex)
);
ALTER TABLE IndividualVertex ADD CONSTRAINT individualvertex_vertex FOREIGN KEY (vertex) REFERENCES VertexName(vertex);
CREATE INDEX vertexname_name ON VertexName (name);
ALTER SEQUENCE VERTEXNAME$IDENTITY_SEQUENCE START WITH 10000;

-- View
--
CREATE VIEW Edges AS
SELECT Edge.id AS edge,
 StartVertexNameString.value AS startName,
 StopVertexNameString.value AS stopName,
 hops,
 entry,
 direct,
 exit,
 start,
 stop
FROM Edge
JOIN VertexName AS StartVertexName ON StartVertexName.vertex = Edge.start
JOIN Sentence AS StartVertexNameString ON StartVertexNameString.id = StartVertexName.name
 AND StartVertexNameString.culture = ClientCulture()
JOIN VertexName AS StopVertexName ON StopVertexName.vertex = Edge.stop
LEFT JOIN Sentence AS StopVertexNameString ON StopVertexNameString.id = StopVertexName.name
 AND StopVertexNameString.culture = ClientCulture()
;

CREATE VIEW EdgeIndividuals AS
SELECT Edge.id AS edge,
 StartVertexNameString.value AS startName,
 StopVertexNameString.value AS stopName,
 StartIndividualVertex.individual AS startIndividual,
 StartType.value AS startType,
 COALESCE(StartPeople.fullname, StartEntities.name) AS startIndividualName,
 StopIndividualVertex.individual AS stopIndividual,
 COALESCE(StopPeople.fullname, StopEntities.name) AS stopIndividualName,
 StopType.value AS stopType,
 hops,
 entry,
 direct,
 exit,
 start,
 Edge.stop
FROM Edge
JOIN VertexName AS StartVertexName ON StartVertexName.vertex = Edge.start
JOIN VertexName AS StopVertexName ON StopVertexName.vertex = Edge.stop
LEFT JOIN Sentence AS StartVertexNameString ON StartVertexNameString.id = StartVertexName.name
 AND StartVertexNameString.culture = ClientCulture()
LEFT JOIN Sentence AS StopVertexNameString ON StopVertexNameString.id = StopVertexName.name
 AND StopVertexNameString.culture = ClientCulture()
LEFT JOIN IndividualVertex AS StartIndividualVertex ON StartIndividualVertex.vertex = Edge.start
LEFT JOIN People AS StartPeople ON StartPeople.individual = StartIndividualVertex.individual
LEFT JOIN Entities AS StartEntities ON StartEntities.individual = StartIndividualVertex.individual
LEFT JOIN Word AS StartType ON StartType.id = StartIndividualVertex.type
 AND StartType.culture IS NULL
LEFT JOIN IndividualVertex AS StopIndividualVertex ON StopIndividualVertex.vertex = Edge.stop
LEFT JOIN People AS StopPeople ON StopPeople.individual = StopIndividualVertex.individual
LEFT JOIN Entities AS StopEntities ON StopEntities.individual = StopIndividualVertex.individual
LEFT JOIN Word AS StopType ON StopType.id = StopIndividualVertex.type
 AND StopType.culture IS NULL
;

-- Functions
--
SET DELIMITER @
CREATE OR REPLACE FUNCTION AddEdge (
 v_start INTEGER,
 v_stop INTEGER
) RETURNS INTEGER AS
VAR v_id INTEGER;

-- can t start and stop at the same place
IF (v_start = v_stop)
 THROW (SELECT 'Start != Stop' FROM DUAL);
 RETURN NULL;
END_IF;

-- detect duplicate
VAR f INTEGER = (
 SELECT id
 FROM Edge
 WHERE start = v_start
 AND stop = v_stop
 AND hops = 0
);
IF (f IS NOT NULL)
 THROW (SELECT 'Duplicate, ' || v_start || ',' || v_stop || ' already exists' FROM DUAL);
 RETURN NULL; -- found duplicate
END_IF;

-- detect circular relation attempt
f = (
 SELECT id
 FROM Edge
 WHERE start = v_stop
 AND stop = v_start
);
IF (f IS NOT NULL)
 THROW (SELECT 'Circular relation rejected' FROM DUAL);
 RETURN NULL; -- found circular conflict
END_IF;

-- insert 0 hop edge
VAR nextid INTEGER = (SELECT NEXT VALUE FOR EDGE$IDENTITY_SEQUENCE FROM DUAL);
INSERT INTO edge (
 id,
 start, stop,
 entry, direct, exit)
VALUES (
 nextid,
 v_start,
 v_stop,
 nextid,
 nextid,
 nextid
);

v_id = nextid;

-- Connect graphs A (start) and B (stop) together
-- Step 1: A s incoming edges to B
INSERT INTO edge (
 start, stop,
 hops,
 entry, direct, exit)
SELECT
 start,
 v_stop,
 hops + 1,
 id,
 v_id,
 v_id
FROM edge
WHERE stop = v_start;

-- Step 2: A to B s outgoing edges
INSERT INTO edge (
 start, stop,
 hops,
 entry, direct, exit)
SELECT
 v_start,
 stop,
 hops + 1,
 v_id,
 v_id,
 id
FROM edge
WHERE start = v_stop;

-- Step 3: A s incoming edges to the stop node of B s outgoing edges
INSERT INTO edge (
 start, stop,
 hops,
 entry, direct, exit)
SELECT
 A.start,
 B.stop,
 A.hops + B.hops + 2,
 A.id,
 v_id,
 B.id
FROM edge A, edge B
WHERE A.stop = v_start
AND B.start = v_stop;

RETURN v_id;
END_FUNCTION;
@
SET DELIMITER ;


SET DELIMITER @
CREATE OR REPLACE PROCEDURE CreateRemoveEdgePurgeList AS
DROP TABLE IF EXISTS removeEdgePurgeList;
CREATE TEMPORARY TABLE removeEdgePurgeList (id int);
END_PROCEDURE;
@
SET DELIMITER ;

EXECUTE CreateRemoveEdgePurgeList;

SET DELIMITER @
CREATE OR REPLACE FUNCTION RemoveEdge (
 v_start INTEGER,
 v_stop INTEGER
) RETURNS INTEGER AS
VAR v_id INTEGER;
VAR v_count INTEGER;
-- detect if it actually exists
v_id = (
 SELECT id
 FROM edge
 WHERE start = v_start
 AND stop = v_stop
 AND hops = 0
);
IF (v_id IS NOT NULL)
 -- continue processing
ELSE
 THROW (SELECT 'Relation ' || v_start || ',' || v_stop || ' does not exists' FROM DUAL);
 RETURN NULL;
END_IF;

EXECUTE CreateRemoveEdgePurgeList;

-- Step 1: rows that were originally inserted for this direct edge
INSERT INTO removeEdgePurgeList
 SELECT id
 FROM edge
 WHERE direct = v_id;

-- Step 2: scan and find all dependent rows that are inserted after first
FOR
 INSERT INTO removeEdgePurgeList
 SELECT id FROM edge
 WHERE hops > 0
 AND (entry IN (SELECT id FROM removeEdgePurgeList)
  OR exit IN (SELECT id FROM removeEdgePurgeList))
 AND id NOT IN (SELECT id FROM removeEdgePurgeList);
END_FOR;

-- count the records to be deleted and then delete them
v_count = (
 SELECT count(id) FROM removeEdgePurgeList
);
DELETE FROM edge
WHERE id IN (SELECT id FROM removeEdgePurgeList);

RETURN v_count;
END_FUNCTION;
@
SET DELIMITER ;


-- Can Return NULL
SET DELIMITER @
CREATE OR REPLACE FUNCTION GetVertex (
 inVertexName STRING
) RETURNS INTEGER DETERMINISTIC AS
RETURN (
 SELECT vertex
 FROM VertexName
 WHERE VertexName.name = GetSentence(inVertexName)
 LIMIT 1
);
END_FUNCTION;
@
SET DELIMITER ;


SET DELIMITER @
CREATE OR REPLACE FUNCTION AddEdgeName (
 inStart STRING,
 inStop  STRING
) RETURNS INTEGER AS
VAR v_start INTEGER;
VAR v_stop  INTEGER;

v_start = GetVertex(inStart);
IF (v_start IS NULL)
 INSERT INTO VertexName (name) VALUES (GetSentence(inStart));
 v_start = (SELECT LAST_INSERT_ID() FROM DUAL);
END_IF;

v_stop = GetVertex(inStop);
IF (v_stop IS NULL)
 INSERT INTO VertexName (name) VALUES (GetSentence(inStop));
 v_stop = (SELECT LAST_INSERT_ID() FROM DUAL);
END_IF;

RETURN AddEdge(v_start, v_stop);
END_FUNCTION;
@
SET DELIMITER ;

SET DELIMITER @
CREATE OR REPLACE FUNCTION RemoveEdgeName (
 inStart STRING,
 inStop  STRING
) RETURNS INTEGER AS
VAR v_start INTEGER;
VAR v_stop  INTEGER;
VAR v_count INTEGER;

v_start = GetVertex(inStart);
v_stop  = GetVertex(inStop);

IF (v_start IS NOT NULL AND v_stop IS NOT NULL)
 v_count = (SELECT RemoveEdge(v_start, v_stop) FROM DUAL);
END_IF;

RETURN v_count;
END_FUNCTION;
@
SET DELIMITER ;


-- Can return NULL
SET DELIMITER @
CREATE OR REPLACE FUNCTION GetIndividualVertex (
 inIndividual BIGINT,
 inVertex  INTEGER
) RETURNS INTEGER AS
RETURN (
 SELECT VertexName.vertex
 FROM IndividualVertex
 JOIN VertexName ON VertexName.vertex = inVertex
 JOIN Edge ON Edge.start = inVertex
 WHERE IndividualVertex.individual = inIndividual
 ORDER BY Edge.hops ASC
 LIMIT 1
);
END_FUNCTION;
@
SET DELIMITER ;


-- Can return NULL
SET DELIMITER @
CREATE OR REPLACE FUNCTION GetIndividualVertex (
 inIndividual BIGINT
) RETURNS INTEGER AS
RETURN (
 SELECT VertexName.vertex
 FROM IndividualVertex
 JOIN VertexName ON VertexName.vertex = IndividualVertex.vertex
 LEFT JOIN Edge ON Edge.start = IndividualVertex.vertex
 WHERE IndividualVertex.individual = inIndividual
 ORDER BY Edge.hops ASC
 LIMIT 1
);
END_FUNCTION;
@
SET DELIMITER ;


-- Vertex without a name
SET DELIMITER @
CREATE OR REPLACE FUNCTION CreateVertex (
) RETURNS INTEGER AS
INSERT INTO VertexName (name) VALUES (NULL);
RETURN LAST_INSERT_ID();
END_FUNCTION;
@
SET DELIMITER ;


SET DELIMITER @
CREATE OR REPLACE FUNCTION SetIndividualVertex (
 inIndividual BIGINT,
 inType STRING
) RETURNS INTEGER AS
VAR v_id INTEGER = GetIndividualVertex(inIndividual);
VAR t_id INTEGER;

IF (inType IS NOT NULL AND inType != '')
 t_id = GetIdentifier(inType);
END_IF;

-- Create no-name Vertex
IF (v_id IS NULL)
 v_id = CreateVertex();
 INSERT INTO IndividualVertex (individual, vertex, type) VALUES (inIndividual, v_id, t_id);
END_IF;

RETURN v_id;
END_FUNCTION;
@
SET DELIMITER ;


SET DELIMITER @
CREATE OR REPLACE FUNCTION SetIndividualVertex (
 inIndividual BIGINT
) RETURNS INTEGER AS
RETURN SetIndividualVertex(inIndividual, NULL);
END_FUNCTION;
@
SET DELIMITER ;
